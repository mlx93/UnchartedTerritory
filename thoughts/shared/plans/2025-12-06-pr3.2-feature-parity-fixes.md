# PR3.2 Feature Parity Fixes Implementation Plan

## Overview

This plan addresses the critical gaps identified during the feature parity analysis between `origin/main` and `myles/vercel-ai-sdk-migration` branches. The fixes ensure the AI SDK path achieves full feature parity with the legacy Go worker path.

## Current State Analysis

### Key Discoveries:

1. **Auto-Render Gap** (`proceed-plan.ts:226`): After `proceedPlanAction` updates plan status to 'applied', no render is triggered. The main branch calls `EnqueueRenderWorkspaceForRevisionWithPendingContent()` at `apply-plan.go:163-164`.

2. **RollbackModal Bug** (`NewChartChatMessage.tsx`): Missing `import { RollbackModal }` (line 14 in ChatMessage.tsx) and missing `<RollbackModal ... />` component instantiation (lines 388-400 in ChatMessage.tsx).

3. **textEditor Delete** (`textEditor.ts:49`, `editor.go:108-117`): The enum only includes `['view', 'create', 'str_replace']` - no delete command exists. FileTree.tsx has UI but empty `onConfirm` handler at lines 485-490.

## Desired End State

After this plan is complete:
1. Plans in AI SDK mode automatically trigger a render after completion
2. Rollback buttons work in both ChatMessage and NewChartChatMessage components
3. Files can be deleted via the textEditor tool and FileTree UI

### Verification:
- AI SDK plan completion triggers visible render in Terminal component
- Clicking rollback button in NewChartChatMessage opens RollbackModal
- Deleting a file via FileTree removes it from the workspace

## What We're NOT Doing

- Feedback Modal backend (deferred - P4 enhancement)
- Provider switching demonstration (nice-to-have from requirements)
- Any changes to the legacy Go worker path

## Implementation Approach

We'll implement fixes in priority order:
1. **Phase 1**: Auto-Render After Plan (Critical path - enables core functionality)
2. **Phase 2**: RollbackModal Bug Fix (Quick fix - copy pattern from ChatMessage.tsx)
3. **Phase 3**: textEditor Delete Command (Enhancement - adds missing capability)

---

## Phase 1: Auto-Render After Plan

### Overview
Add auto-render trigger to `proceedPlanAction` after plan is successfully applied. This mirrors the behavior in `apply-plan.go:160-170`.

### Changes Required:

#### 1.1 Create Render Trigger Action

**File**: `chartsmith-app/lib/workspace/actions/trigger-render.ts` (NEW FILE)
**Purpose**: Trigger a render for a workspace revision via the Go backend

```typescript
"use server";

import { callGoEndpoint } from "@/lib/ai/tools/utils";

interface TriggerRenderRequest {
  workspaceId: string;
  revisionNumber: number;
  chatMessageId: string;
  usePendingContent: boolean;
}

interface TriggerRenderResponse {
  success: boolean;
  renderId?: string;
  message?: string;
}

/**
 * Triggers a render for a workspace revision via the Go backend
 *
 * @param workspaceId - The workspace to render
 * @param revisionNumber - The revision number to render
 * @param chatMessageId - The chat message to associate the render with
 * @param usePendingContent - Whether to use pending content (true for AI SDK path)
 * @param authHeader - Authorization header
 */
export async function triggerRenderAction(
  workspaceId: string,
  revisionNumber: number,
  chatMessageId: string,
  usePendingContent: boolean,
  authHeader?: string
): Promise<TriggerRenderResponse> {
  try {
    const response = await callGoEndpoint<TriggerRenderResponse>(
      "/api/render/trigger",
      {
        workspaceId,
        revisionNumber,
        chatMessageId,
        usePendingContent,
      } as TriggerRenderRequest,
      authHeader
    );
    return response;
  } catch (error) {
    console.error("[triggerRenderAction] Failed to trigger render:", error);
    return {
      success: false,
      message: error instanceof Error ? error.message : "Failed to trigger render",
    };
  }
}
```

#### 1.2 Add Go Backend Endpoint for Render Trigger

**File**: `pkg/api/handlers/render.go` (NEW FILE)
**Purpose**: HTTP handler that wraps the existing `EnqueueRenderWorkspaceForRevisionWithPendingContent` function

```go
package handlers

import (
	"encoding/json"
	"net/http"

	"github.com/replicatedhq/chartsmith/pkg/logger"
	"github.com/replicatedhq/chartsmith/pkg/workspace"
	"go.uber.org/zap"
)

// TriggerRenderRequest represents a request to trigger a render
type TriggerRenderRequest struct {
	WorkspaceID       string `json:"workspaceId"`
	RevisionNumber    int    `json:"revisionNumber"`
	ChatMessageID     string `json:"chatMessageId"`
	UsePendingContent bool   `json:"usePendingContent"`
}

// TriggerRenderResponse represents the response from the render trigger endpoint
type TriggerRenderResponse struct {
	Success  bool   `json:"success"`
	RenderID string `json:"renderId,omitempty"`
	Message  string `json:"message,omitempty"`
}

// TriggerRender handles requests to trigger a workspace render
// POST /api/render/trigger
func TriggerRender(w http.ResponseWriter, r *http.Request) {
	var req TriggerRenderRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		logger.Debug("Failed to decode trigger render request", zap.Error(err))
		writeBadRequest(w, "Invalid request body")
		return
	}

	// Validate required fields
	if req.WorkspaceID == "" {
		writeBadRequest(w, "workspaceId is required")
		return
	}
	if req.ChatMessageID == "" {
		writeBadRequest(w, "chatMessageId is required")
		return
	}

	ctx := r.Context()

	logger.Info("Triggering render",
		zap.String("workspaceId", req.WorkspaceID),
		zap.Int("revisionNumber", req.RevisionNumber),
		zap.String("chatMessageId", req.ChatMessageID),
		zap.Bool("usePendingContent", req.UsePendingContent))

	var err error
	if req.UsePendingContent {
		err = workspace.EnqueueRenderWorkspaceForRevisionWithPendingContent(
			ctx, req.WorkspaceID, req.RevisionNumber, req.ChatMessageID)
	} else {
		err = workspace.EnqueueRenderWorkspaceForRevision(
			ctx, req.WorkspaceID, req.RevisionNumber, req.ChatMessageID)
	}

	if err != nil {
		logger.Error("Failed to trigger render", zap.Error(err))
		writeJSON(w, http.StatusOK, TriggerRenderResponse{
			Success: false,
			Message: "Failed to trigger render: " + err.Error(),
		})
		return
	}

	writeJSON(w, http.StatusOK, TriggerRenderResponse{
		Success: true,
		Message: "Render triggered successfully",
	})
}
```

#### 1.3 Register the New Endpoint

**File**: `pkg/api/server.go`
**Changes**: Add new route registration after line 38 (after conversion/start)

```go
	// PR3.2: Render trigger endpoint (for AI SDK auto-render after plan)
	mux.HandleFunc("POST /api/render/trigger", handlers.TriggerRender)
```

#### 1.4 Update proceedPlanAction to Trigger Render

**File**: `chartsmith-app/lib/workspace/actions/proceed-plan.ts`
**Changes**: Add render trigger after plan is successfully applied

Add import at top:
```typescript
import { triggerRenderAction } from "./trigger-render";
```

Add render trigger after line 226 (after `publishPlanUpdate` for 'applied' status):

```typescript
        // Notify frontend of status change to 'applied'
        await publishPlanUpdate(workspaceId, planId, authHeader);

        // PR3.2: Trigger auto-render after plan is applied (matches apply-plan.go:160-170)
        // Get the chat message ID associated with this plan
        const chatMsgResult = await client2.query(
          `SELECT wc.id FROM workspace_chat wc
           JOIN workspace_plan wp ON wp.id = $1
           WHERE wc.response_plan_id = wp.id
           ORDER BY wc.created_at DESC
           LIMIT 1`,
          [planId]
        );

        if (chatMsgResult.rows.length > 0) {
          const chatMessageId = chatMsgResult.rows[0].id;
          const renderResult = await triggerRenderAction(
            workspaceId,
            revisionNumber,
            chatMessageId,
            true, // usePendingContent = true for AI SDK path
            authHeader
          );

          if (!renderResult.success) {
            console.warn('[proceedPlanAction] Failed to trigger auto-render:', renderResult.message);
            // Don't throw - plan is already applied, render failure is non-fatal
          }
        } else {
          console.warn('[proceedPlanAction] No chat message found for plan, skipping auto-render');
        }
```

### Success Criteria:

#### Automated Verification:
- [ ] TypeScript compiles without errors: `cd chartsmith-app && npm run build`
- [ ] Go compiles without errors: `cd pkg && go build ./...`
- [ ] Existing tests pass: `cd chartsmith-app && npm test`

#### Manual Verification:
- [ ] Create a new chart via AI SDK chat
- [ ] See plan generated with file changes
- [ ] Click "Proceed" on plan
- [ ] Verify Terminal component appears with helm template output
- [ ] Verify render is marked as `is_autorender: true` in database

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation from the human that the manual testing was successful before proceeding to the next phase.

---

## Phase 2: RollbackModal Bug Fix

### Overview
Add missing RollbackModal import and component to NewChartChatMessage.tsx, matching the pattern from ChatMessage.tsx.

### Changes Required:

#### 2.1 Add RollbackModal Import

**File**: `chartsmith-app/components/NewChartChatMessage.tsx`
**Changes**: Add import statement after line 12 (after PlanChatMessage import)

```typescript
import { RollbackModal } from "@/components/RollbackModal";
```

#### 2.2 Add RollbackModal Component

**File**: `chartsmith-app/components/NewChartChatMessage.tsx`
**Changes**: Add RollbackModal component after line 360 (after FeedbackModal, before closing `</div>`)

```typescript
      {message.responseRollbackToRevisionNumber !== undefined && (
        <RollbackModal
          isOpen={showRollbackModal}
          onClose={() => setShowRollbackModal(false)}
          workspaceId={workspace.id}
          revisionNumber={message.responseRollbackToRevisionNumber}
          session={session}
          onSuccess={(updatedWorkspace, updatedMessages) => {
            setWorkspace(updatedWorkspace);
            setMessages(updatedMessages);
          }}
        />
      )}
```

### Success Criteria:

#### Automated Verification:
- [ ] TypeScript compiles without errors: `cd chartsmith-app && npm run build`
- [ ] Linting passes: `cd chartsmith-app && npm run lint`

#### Manual Verification:
- [ ] Navigate to a workspace with multiple revisions
- [ ] Find a message with rollback link in NewChartChatMessage view
- [ ] Click "rollback to this revision" button
- [ ] Verify RollbackModal appears with 5-second countdown
- [ ] Verify rollback completes and workspace reverts

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation from the human that the manual testing was successful before proceeding to the next phase.

---

## Phase 3: textEditor Delete Command

### Overview
Add delete command support to the textEditor tool, enabling file deletion via AI SDK and FileTree UI.

### Changes Required:

#### 3.1 Update TypeScript Tool Schema

**File**: `chartsmith-app/lib/ai/tools/textEditor.ts`
**Changes**: Update enum and add description

Replace lines 39-62 with:

```typescript
  return tool({
    description: `View, edit, create, or delete files in the chart.

Commands:
- view: Read the contents of a file. Returns the file content or an error if the file doesn't exist.
- create: Create a new file with the specified content. Fails if the file already exists.
- str_replace: Replace text in a file. Uses fuzzy matching if exact match is not found.
- delete: Delete an existing file. Fails if the file is required (Chart.yaml, values.yaml).

Use view to inspect files before editing. Use create for new files. Use str_replace for modifications. Use delete to remove files.`,
    inputSchema: z.object({
      command: z.enum(['view', 'create', 'str_replace', 'delete'])
        .describe('The operation to perform: view, create, str_replace, or delete'),
      path: z.string()
        .describe('File path relative to chart root (e.g., "templates/deployment.yaml", "values.yaml")'),
      content: z.string()
        .optional()
        .describe('For create command: the full content of the new file'),
      oldStr: z.string()
        .optional()
        .describe('For str_replace command: the exact text to find and replace'),
      newStr: z.string()
        .optional()
        .describe('For str_replace command: the text to replace oldStr with'),
    }),
    execute: async (params: { command: 'view' | 'create' | 'str_replace' | 'delete'; path: string; content?: string; oldStr?: string; newStr?: string }) => {
```

#### 3.2 Update Buffered Tools Schema

**File**: `chartsmith-app/lib/ai/tools/bufferedTools.ts`
**Changes**: Update the textEditor command enum in the buffered tools (around line 66)

Find the line with `command: z.enum(["view", "create", "str_replace"])` and replace with:

```typescript
      command: z.enum(["view", "create", "str_replace", "delete"])
```

Also update the execute function to handle delete as a buffered operation (similar to create/str_replace):

```typescript
    // DELETE: Buffer for plan workflow (same as create/str_replace)
    if (params.command === "delete") {
      onToolCall({
        id: toolCallId,
        toolName: "textEditor",
        args: params,
        timestamp: Date.now(),
      });

      return {
        success: true,
        message: `File deletion will be applied after review: delete ${params.path}`,
        buffered: true,
      };
    }
```

#### 3.3 Add Go Backend Delete Handler

**File**: `pkg/api/handlers/editor.go`
**Changes**: Add delete case to switch statement and handler function

Add case in switch statement (after line 114, before default):

```go
	case "delete":
		handleDelete(ctx, w, req)
```

Add handler function after `handleStrReplace` function (after line 307):

```go
// handleDelete handles the delete command - deletes a file
func handleDelete(ctx context.Context, w http.ResponseWriter, req TextEditorRequest) {
	// Check for required files that cannot be deleted
	fileName := req.Path
	if idx := strings.LastIndex(req.Path, "/"); idx >= 0 {
		fileName = req.Path[idx+1:]
	}

	if fileName == "Chart.yaml" || fileName == "values.yaml" {
		writeJSON(w, http.StatusOK, TextEditorResponse{
			Success: false,
			Message: "Error: Cannot delete required file " + fileName + ". This file is essential for the Helm chart.",
		})
		return
	}

	// Get charts to find the file
	charts, err := workspace.ListCharts(ctx, req.WorkspaceID, req.RevisionNumber)
	if err != nil {
		logger.Debug("Failed to list charts", zap.Error(err))
		writeInternalError(w, "Failed to access workspace")
		return
	}

	// Find the file
	var foundFile *struct {
		chartID string
		fileID  string
		path    string
	}

	for _, chart := range charts {
		for _, file := range chart.Files {
			if file.FilePath == req.Path {
				foundFile = &struct {
					chartID string
					fileID  string
					path    string
				}{
					chartID: chart.ID,
					fileID:  file.ID,
					path:    file.FilePath,
				}
				break
			}
		}
		if foundFile != nil {
			break
		}
	}

	if foundFile == nil {
		writeJSON(w, http.StatusOK, TextEditorResponse{
			Success: false,
			Message: "Error: File does not exist.",
		})
		return
	}

	// Delete the file
	err = workspace.DeleteFile(ctx, req.WorkspaceID, req.RevisionNumber, foundFile.chartID, req.Path)
	if err != nil {
		logger.Debug("Failed to delete file", zap.Error(err))
		writeInternalError(w, "Failed to delete file")
		return
	}

	// Publish realtime update for file explorer (with nil content to indicate deletion)
	publishArtifactDeletedUpdate(ctx, req.WorkspaceID, req.RevisionNumber, foundFile.chartID, foundFile.fileID, req.Path)

	writeJSON(w, http.StatusOK, TextEditorResponse{
		Success: true,
		Message: "File deleted successfully",
	})
}

// publishArtifactDeletedUpdate sends a Centrifugo event to update file explorer when a file is deleted
func publishArtifactDeletedUpdate(ctx context.Context, workspaceID string, revisionNumber int, chartID, fileID, filePath string) {
	logger.Debug("Publishing artifact deleted update",
		zap.String("workspaceID", workspaceID),
		zap.String("fileID", fileID),
		zap.String("filePath", filePath))

	userIDs, err := workspace.ListUserIDsForWorkspace(ctx, workspaceID)
	if err != nil {
		logger.Errorf("Failed to get user IDs for realtime workspaceID=%s: %v", workspaceID, err)
		return
	}

	recipient := realtimetypes.Recipient{UserIDs: userIDs}
	event := &realtimetypes.ArtifactDeletedEvent{
		WorkspaceID: workspaceID,
		FileID:      fileID,
		FilePath:    filePath,
	}

	if err := realtime.SendEvent(ctx, recipient, event); err != nil {
		logger.Errorf("Failed to send artifact deleted event workspaceID=%s: %v", workspaceID, err)
	} else {
		logger.Debug("Successfully published artifact deleted update", zap.String("filePath", filePath))
	}
}
```

#### 3.4 Add Workspace DeleteFile Function

**File**: `pkg/workspace/file.go` (or appropriate file)
**Changes**: Add DeleteFile function

```go
// DeleteFile removes a file from the workspace
func DeleteFile(ctx context.Context, workspaceID string, revisionNumber int, chartID, filePath string) error {
	conn := persistence.MustGetPooledPostgresSession()
	defer conn.Release()

	query := `DELETE FROM workspace_file
	          WHERE workspace_id = $1
	          AND revision_number = $2
	          AND chart_id = $3
	          AND file_path = $4`

	result, err := conn.Exec(ctx, query, workspaceID, revisionNumber, chartID, filePath)
	if err != nil {
		return fmt.Errorf("failed to delete file: %w", err)
	}

	if result.RowsAffected() == 0 {
		return fmt.Errorf("file not found")
	}

	return nil
}
```

#### 3.5 Add ArtifactDeletedEvent Type

**File**: `pkg/realtime/types/artifact-deleted.go` (NEW FILE)
**Purpose**: Define the event type for file deletions (must implement Event interface like ArtifactUpdatedEvent)

```go
package types

// Ensure ArtifactDeletedEvent implements Event interface
var _ Event = ArtifactDeletedEvent{}

// ArtifactDeletedEvent represents a file deletion event
type ArtifactDeletedEvent struct {
	WorkspaceID string `json:"workspaceId"`
	FileID      string `json:"fileId"`
	FilePath    string `json:"filePath"`
}

func (e ArtifactDeletedEvent) GetMessageData() (map[string]interface{}, error) {
	return map[string]interface{}{
		"eventType":   "artifact-deleted",
		"workspaceId": e.WorkspaceID,
		"fileId":      e.FileID,
		"filePath":    e.FilePath,
	}, nil
}

func (e ArtifactDeletedEvent) GetChannelName() string {
	return e.WorkspaceID
}
```

#### 3.6 Update FileTree onConfirm Handler

**File**: `chartsmith-app/components/FileTree.tsx`
**Changes**: Connect the onConfirm handler to actually delete the file

First, add necessary imports and props. Update the component to accept delete action:

```typescript
// Add to imports
import { callGoEndpoint } from "@/lib/ai/tools/utils";
import { workspaceAtom } from "@/atoms/workspace";

// Update FileTreeProps interface
interface FileTreeProps {
  files: WorkspaceFile[];
  charts: Chart[];
  workspaceId: string;
  revisionNumber: number;
  authHeader?: string;
}
```

Update the component signature and add delete handler:

```typescript
export function FileTree({ files = [], charts = [], workspaceId, revisionNumber, authHeader }: FileTreeProps) {
```

Replace the onConfirm handler at lines 485-490:

```typescript
        onConfirm={async () => {
          if (!deleteModal.isRequired && deleteModal.filePath) {
            try {
              const response = await callGoEndpoint<{ success: boolean; message?: string }>(
                '/api/tools/editor',
                {
                  command: 'delete',
                  workspaceId,
                  revisionNumber,
                  path: deleteModal.filePath,
                },
                authHeader
              );

              if (!response.success) {
                console.error('Failed to delete file:', response.message);
                // TODO: Show error toast
              }
            } catch (error) {
              console.error('Failed to delete file:', error);
              // TODO: Show error toast
            }
          }
          setDeleteModal({ isOpen: false, filePath: "", isRequired: false });
        }}
```

#### 3.7 Update FileTree Usage Sites

**File**: `chartsmith-app/components/FileBrowser.tsx`
**Changes**: Pass new required props to FileTree (FileTree is used at line 44)

Update the FileTree usage around line 44-46:

```typescript
        <FileTree
          files={looseFiles}
          charts={charts}
          workspaceId={workspace.id}
          revisionNumber={workspace.currentRevisionNumber}
          authHeader={session?.user?.authHeader}
        />
```

**Note**: FileBrowser.tsx will need access to `workspace` and `session`. Check if these are already available via props or context, or add them as needed.

#### 3.8 Handle artifact-deleted Events in Frontend

**File**: `chartsmith-app/hooks/useCentrifugo.ts`
**Changes**: Add handler for artifact-deleted events to remove files from state

Add event handler function (near other handler definitions around line 460):

```typescript
const handleArtifactDeletedMessage = useCallback((data: CentrifugoMessageData) => {
  if (!data.fileId || !data.filePath) return;

  // Remove file from charts state
  setCharts(prevCharts =>
    prevCharts.map(chart => ({
      ...chart,
      files: chart.files.filter(file => file.id !== data.fileId)
    }))
  );
}, [setCharts]);
```

Add case in the event type if-else chain (after line 499, after `artifact-updated` case):

```typescript
    } else if (eventType === 'artifact-deleted') {
      handleArtifactDeletedMessage(message.data);
    }
```

### Success Criteria:

#### Automated Verification:
- [ ] TypeScript compiles without errors: `cd chartsmith-app && npm run build`
- [ ] Go compiles without errors: `cd pkg && go build ./...`
- [ ] Linting passes: `cd chartsmith-app && npm run lint && cd ../pkg && golangci-lint run`

#### Manual Verification:
- [ ] Create a test file via AI SDK (e.g., "create templates/test.yaml")
- [ ] Verify file appears in FileTree
- [ ] Click delete button on the test file
- [ ] Confirm deletion in modal
- [ ] Verify file disappears from FileTree
- [ ] Attempt to delete Chart.yaml - verify it's blocked
- [ ] Attempt to delete values.yaml - verify it's blocked

**Implementation Note**: After completing this phase and all automated verification passes, pause here for manual confirmation from the human that the manual testing was successful before proceeding.

---

## Testing Strategy

### Unit Tests:
- Test `triggerRenderAction` with mock Go endpoint
- Test delete command validation (required files blocked)
- Test RollbackModal renders correctly

### Integration Tests:
- End-to-end plan proceed with auto-render
- End-to-end file deletion flow
- Rollback from NewChartChatMessage

### Manual Testing Steps:
1. Create new chart via AI SDK
2. Make file changes via chat
3. Proceed with plan â†’ verify render appears
4. Make more changes
5. Click rollback on earlier revision
6. Create a test file
7. Delete the test file via FileTree

## Performance Considerations

- Auto-render uses existing `EnqueueRenderWorkspaceForRevision` which checks for duplicate renders
- File deletion is a simple DELETE query - no performance concerns
- RollbackModal fix is pure UI - no performance impact

## Migration Notes

None required - all changes are additive or bug fixes.

## References

- Original research: `thoughts/shared/research/2025-12-06-chartsmith-ai-sdk-feature-parity.md`
- Main branch auto-render: `pkg/listener/apply-plan.go:160-170`
- Main branch render enqueue: `pkg/workspace/rendered.go:307-315`
- ChatMessage RollbackModal pattern: `chartsmith-app/components/ChatMessage.tsx:388-400`
