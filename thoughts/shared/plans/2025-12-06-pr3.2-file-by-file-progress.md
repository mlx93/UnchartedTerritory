# PR3.2: File-by-File Progress Updates Implementation Plan

**Date**: 2025-12-06
**Status**: Implemented
**Related**: PR3.0 Buffered Tool Calls, PR3.1 AI SDK UX Improvements

## Overview

Add real-time file-by-file progress updates when executing AI SDK plans via `proceedPlanAction`. Currently, all files change instantly without visual feedback. This plan implements per-file status transitions with real-time UI updates.

## Current State

### What Works
- Plan status transitions: `review` → `applying` → `applied` ✅
- Proceed button disappears when status becomes `applying` ✅
- Backend publishes plan events via Centrifugo after status changes ✅
- UI renders different states for action files (`pending` → `creating` → `created`) ✅

### What's Missing
- `proceedPlanAction` (TypeScript) doesn't update individual action file statuses
- All files appear to change at once after completion
- No spinner shown for files being processed

## Architecture Analysis

### Existing Pattern in Go (Legacy Path)

The Go listener (`apply-plan.go:98-134`) already implements file-by-file updates:

```go
for i, actionFile := range plan.ActionFiles {
    // 1. Update status to 'creating'
    updateActionFileStatus(ctx, plan.ID, actionFile.Path, "creating")

    // 2. Publish plan update event
    realtime.SendEvent(ctx, recipient, PlanUpdatedEvent{Plan: updatedPlan})

    // 3. Process the file
    processActionFile(ctx, w, updatedPlan, actionFile, recipient)

    // 4. After processing, status becomes 'created'
}
```

### AI SDK Path (TypeScript)

Current implementation (`proceed-plan.ts:117-152`):
```typescript
for (const toolCall of bufferedToolCalls) {
    // Execute tool call - NO status updates per file
    await callGoEndpoint("/api/tools/editor", {...});
    successCount++;
}
```

## Implementation Plan

### Phase 1: Add Action File Status Update Endpoint (Go Backend)

**File**: `chartsmith/pkg/api/handlers/plan.go`

Add new endpoint to update individual action file status:

```go
// UpdateActionFileStatusRequest represents a request to update a single action file's status
type UpdateActionFileStatusRequest struct {
    WorkspaceID string `json:"workspaceId"`
    PlanID      string `json:"planId"`
    Path        string `json:"path"`
    Status      string `json:"status"` // "pending", "creating", "created"
}

// UpdateActionFileStatus updates a single action file's status and publishes the plan update
// POST /api/plan/update-action-file-status
func UpdateActionFileStatus(w http.ResponseWriter, r *http.Request) {
    // 1. Validate request
    // 2. Update action file status in DB
    // 3. Publish plan update event
}
```

**Changes Required**:
1. Add `UpdateActionFileStatus` handler function (~30 lines)
2. Register endpoint in `pkg/api/server.go`

### Phase 2: Update TypeScript proceed-plan.ts

**File**: `chartsmith-app/lib/workspace/actions/proceed-plan.ts`

Add helper function and modify the tool call loop:

```typescript
/**
 * Updates the status of a single action file and publishes the plan update
 */
async function updateActionFileStatus(
  workspaceId: string,
  planId: string,
  path: string,
  status: 'pending' | 'creating' | 'created',
  authHeader?: string
): Promise<void> {
  try {
    await callGoEndpoint<{ success: boolean }>(
      "/api/plan/update-action-file-status",
      { workspaceId, planId, path, status },
      authHeader
    );
  } catch (error) {
    console.error("[proceedPlanAction] Failed to update action file status:", error);
    // Don't throw - this is a best-effort notification
  }
}
```

Modify the tool call loop (lines 117-152):

```typescript
for (const toolCall of bufferedToolCalls) {
  if (toolCall.toolName === "textEditor") {
    const args = toolCall.args as { path: string; /* ... */ };

    // 1. Mark file as 'creating' BEFORE execution
    await updateActionFileStatus(workspaceId, planId, args.path, 'creating', authHeader);

    try {
      // 2. Execute the tool call
      await callGoEndpoint<TextEditorResponse>(
        "/api/tools/editor",
        { /* ... */ },
        authHeader
      );

      // 3. Mark file as 'created' AFTER success
      await updateActionFileStatus(workspaceId, planId, args.path, 'created', authHeader);
      successCount++;
    } catch (error) {
      // 4. On failure, could optionally mark as 'failed' or leave as 'creating'
      console.error(`[proceedPlanAction] Failed to execute tool call ${toolCall.id}:`, error);
      failureCount++;
    }
  }
}
```

### Phase 3: No Frontend Changes Required

The UI already handles these statuses correctly in `PlanChatMessage.tsx:289-308`:

```typescript
{actionFile.status === 'created' ? (
  <CheckCircle2Icon className="text-green-500" />
) : actionFile.status === 'creating' ? (
  <Loader2Icon className="animate-spin text-blue-500" />
) : (
  // Show action icon (create/update/delete)
)}
```

The Centrifugo handler (`useCentrifugo.ts:480-485`) already updates plans in state when `plan-updated` events arrive.

## Files to Modify

| File | Changes | Lines |
|------|---------|-------|
| `chartsmith/pkg/api/handlers/plan.go` | Add `UpdateActionFileStatus` handler | +50 |
| `chartsmith/pkg/api/server.go` | Register new endpoint | +1 |
| `chartsmith-app/lib/workspace/actions/proceed-plan.ts` | Add helper + modify loop | +30, ~20 modified |

## Detailed Implementation

### Go: New Handler (plan.go)

```go
// UpdateActionFileStatusRequest represents a request to update a single action file's status
type UpdateActionFileStatusRequest struct {
    WorkspaceID string `json:"workspaceId"`
    PlanID      string `json:"planId"`
    Path        string `json:"path"`
    Status      string `json:"status"`
}

// UpdateActionFileStatus updates a single action file's status and publishes the plan update
// POST /api/plan/update-action-file-status
func UpdateActionFileStatus(w http.ResponseWriter, r *http.Request) {
    var req UpdateActionFileStatusRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        writeBadRequest(w, "Invalid request body")
        return
    }

    // Validate required fields
    if req.WorkspaceID == "" || req.PlanID == "" || req.Path == "" || req.Status == "" {
        writeBadRequest(w, "workspaceId, planId, path, and status are required")
        return
    }

    // Validate status value
    validStatuses := map[string]bool{"pending": true, "creating": true, "created": true}
    if !validStatuses[req.Status] {
        writeBadRequest(w, "status must be one of: pending, creating, created")
        return
    }

    ctx, cancel := context.WithTimeout(r.Context(), 10*time.Second)
    defer cancel()

    // Update the action file status in DB
    conn := persistence.MustGetPooledPostgresSession()
    defer conn.Release()

    tx, err := conn.Begin(ctx)
    if err != nil {
        writeInternalError(w, "Failed to begin transaction")
        return
    }
    defer tx.Rollback(ctx)

    // Get current plan
    plan, err := workspace.GetPlan(ctx, tx, req.PlanID)
    if err != nil {
        writeInternalError(w, "Failed to get plan: "+err.Error())
        return
    }

    // Update the specific action file's status
    found := false
    for i, af := range plan.ActionFiles {
        if af.Path == req.Path {
            plan.ActionFiles[i].Status = req.Status
            found = true
            break
        }
    }

    if !found {
        writeBadRequest(w, "Action file not found: "+req.Path)
        return
    }

    // Save updated action files
    if err := workspace.UpdatePlanActionFiles(ctx, tx, plan.ID, plan.ActionFiles); err != nil {
        writeInternalError(w, "Failed to update action files: "+err.Error())
        return
    }

    if err := tx.Commit(ctx); err != nil {
        writeInternalError(w, "Failed to commit transaction: "+err.Error())
        return
    }

    // Publish plan update event
    publishPlanUpdate(ctx, req.WorkspaceID, req.PlanID)

    writeJSON(w, http.StatusOK, map[string]interface{}{
        "success": true,
    })
}
```

### Go: Register Endpoint (server.go)

Add to the route registration section:

```go
r.HandleFunc("/api/plan/update-action-file-status", handlers.UpdateActionFileStatus).Methods("POST")
```

### TypeScript: Updated proceed-plan.ts

```typescript
/**
 * Updates the status of a single action file and publishes the plan update
 */
async function updateActionFileStatus(
  workspaceId: string,
  planId: string,
  path: string,
  status: 'pending' | 'creating' | 'created',
  authHeader?: string
): Promise<void> {
  try {
    await callGoEndpoint<{ success: boolean }>(
      "/api/plan/update-action-file-status",
      { workspaceId, planId, path, status },
      authHeader
    );
  } catch (error) {
    console.error("[proceedPlanAction] Failed to update action file status:", error);
    // Don't throw - this is a best-effort notification
  }
}

// In proceedPlanAction, modify the tool call loop:
for (const toolCall of bufferedToolCalls) {
  if (toolCall.toolName === "textEditor") {
    const args = toolCall.args as {
      command: string;
      path: string;
      content?: string;
      oldStr?: string;
      newStr?: string;
    };

    // Mark file as 'creating' before execution
    await updateActionFileStatus(workspaceId, planId, args.path, 'creating', authHeader);

    try {
      await callGoEndpoint<TextEditorResponse>(
        "/api/tools/editor",
        {
          command: args.command,
          workspaceId,
          path: args.path,
          content: args.content,
          oldStr: args.oldStr,
          newStr: args.newStr,
          revisionNumber,
        },
        authHeader
      );

      // Mark file as 'created' after success
      await updateActionFileStatus(workspaceId, planId, args.path, 'created', authHeader);
      successCount++;
    } catch (error) {
      console.error(
        `[proceedPlanAction] Failed to execute tool call ${toolCall.id}:`,
        error
      );
      failureCount++;
      // Note: On failure, file remains in 'creating' status
      // This could be changed to a 'failed' status if desired
    }
  }
}
```

## Sequence Diagram

```
User clicks Proceed
       │
       ▼
proceedPlanAction()
       │
       ├── UPDATE plan status = 'applying'
       ├── publishPlanUpdate() → UI: Proceed button disappears
       │
       ▼
for each buffered tool call:
       │
       ├── updateActionFileStatus(path, 'creating')
       │        │
       │        ├── UPDATE workspace_plan_action_file SET status = 'creating'
       │        └── publishPlanUpdate() → UI: Shows spinner for this file
       │
       ├── callGoEndpoint("/api/tools/editor") → File created/modified
       │
       └── updateActionFileStatus(path, 'created')
                │
                ├── UPDATE workspace_plan_action_file SET status = 'created'
                └── publishPlanUpdate() → UI: Shows checkmark for this file
       │
       ▼
UPDATE plan status = 'applied'
publishPlanUpdate() → UI: Shows completion state
```

## Testing Checklist

- [ ] Create workspace with multi-file plan (3+ files)
- [ ] Click Proceed
- [ ] Verify: First file shows spinner immediately
- [ ] Verify: First file shows checkmark after ~1-2 seconds
- [ ] Verify: Second file shows spinner while first shows checkmark
- [ ] Verify: Process continues file-by-file
- [ ] Verify: Final state shows all checkmarks
- [ ] Test error case: One file fails, others continue

## Performance Considerations

1. **Network overhead**: Each file requires 2 additional API calls (creating → created)
   - For a 5-file plan: 10 extra API calls
   - Each call is lightweight (~200-500ms round trip)
   - Total additional time: ~5-10 seconds for large plans

2. **Mitigation options** (future optimization):
   - Batch status updates (update multiple files in one call)
   - Use WebSocket for status updates instead of REST
   - For now, the visual feedback is worth the small overhead

## Dependencies

- PR3.0: BufferedToolCalls field and GetPlan query ✅ (already implemented)
- PR3.1: publishPlanUpdate endpoint ✅ (already implemented)
- Frontend status rendering ✅ (already implemented)

## Rollback Plan

If issues arise:
1. Remove the `updateActionFileStatus` calls from TypeScript
2. Remove the new Go endpoint
3. Files will still be created, just without per-file progress

---

*Plan created: 2025-12-06*
