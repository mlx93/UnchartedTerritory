---
date: 2025-12-05T01:28:04Z
researcher: Claude
git_commit: b23674a2df458f0e2b978d8331d94fc48df95f84
branch: main
repository: mlx93/UnchartedTerritory
topic: "PR1.7 PRD Evaluation Post PR1.6/1.61/1.65 Implementation"
tags: [research, codebase, pr1.7, revision-tracking, centrifugo, plan-workflow, test-ai-chat]
status: complete
last_updated: 2025-12-04
last_updated_by: Claude
---

# Research: PR1.7 PRD Evaluation After PR1.6/1.61/1.65 Implementation

**Date**: 2025-12-05T01:28:04Z
**Researcher**: Claude
**Git Commit**: b23674a2df458f0e2b978d8331d94fc48df95f84
**Branch**: main
**Repository**: mlx93/UnchartedTerritory

## Research Question

Evaluate the PR1.7 PRDs given the completed implementation of PRs 1.6, 1.61, and 1.65. Identify questions, gaps, and required changes to the PR1.7 plan based on the current codebase state.

## Summary

After analyzing the completed PRs 1.6, 1.61, and 1.65, several **critical gaps and inconsistencies** have been identified in the PR1.7 plan:

1. **The `textEditor` tool has inconsistent content handling** - `create` writes to `content` directly, while `str_replace` writes to `content_pending`. The PR1.7 revision tracking plan assumes all AI changes go to `content_pending`.

2. **Centrifugo's `ArtifactUpdatedEvent` is defined but never published** - The frontend handler exists and works, but no Go code actually publishes this event. PR1.7's plan to add publishing is correct but needs implementation details.

3. **The refetch-after-tool-completion approach needs reconciliation** - Test-ai-chat currently refetches workspace after tool execution. This should be removed or coordinated with Centrifugo integration.

4. **Plan workflow creates a parallel system** - The proposed `planProposal` tool approach creates a different mechanism than the existing Go-worker Plan system, raising questions about consistency.

---

## Detailed Findings

### 1. Current Test-AI-Chat Implementation (Post PR1.6/1.61/1.65)

#### Layout Structure
The test-ai-chat path now has a **4-section layout**:
- **Left Sidebar** (16px): Navigation icons (Home, Workspace) + UserMenu
- **Chat Panel** (480px): Scrolling messages + fixed input area
- **File Explorer** (260px): FileBrowser component
- **Code Editor** (flex-1): Monaco editor with Source/Rendered tabs

**Files**:
- `chartsmith/chartsmith-app/app/test-ai-chat/[workspaceId]/client.tsx:283-719`

#### useChat Configuration (PR1.61 Fix Applied)
Body parameters are **NOT passed to useChat()** - they're calculated fresh on each request via `getChatBody()` callback:

```typescript
// client.tsx:80-85
const getChatBody = useCallback(() => ({
  provider: selectedProvider,
  model: selectedModel,
  workspaceId: workspace.id,
  revisionNumber,
}), [selectedProvider, selectedModel, workspace.id, revisionNumber]);
```

`sendMessage()` calls pass body at request time:
- `client.tsx:145-148` (auto-send)
- `client.tsx:210-212` (manual send)

#### Chat Persistence (PR1.6 Implementation)
- **User messages**: `createAISDKChatMessageAction()` persists before sending to AI SDK
- **AI responses**: `updateChatMessageResponseAction()` persists when `status === 'ready'`
- **Initial messages**: Loaded via `getWorkspaceMessagesAction()` from server component

**Files**:
- `lib/workspace/actions/create-ai-sdk-chat-message.ts`
- `lib/workspace/actions/update-chat-message-response.ts`

#### File Explorer Updates (Current Approach)
**Method**: Manual refetch after tool execution (NOT real-time)

```typescript
// client.tsx:153-169
useEffect(() => {
  const lastMessage = messages[messages.length - 1];
  const hasToolResult = lastMessage?.parts?.some(
    (p: { type: string; state?: string }) =>
      p.type.startsWith('tool-') && p.state === 'result'
  );

  if (hasToolResult && status === 'ready') {
    getWorkspaceAction(session, workspace.id).then((updated) => {
      if (updated) setWorkspace(updated);
    });
  }
}, [messages, status, session, workspace.id, setWorkspace]);
```

**Implication for PR1.7**: This refetch logic should be removed or coordinated once Centrifugo integration is added.

#### Pending Changes UI
**Status**: NOT IMPLEMENTED in test-ai-chat

The atoms exist in `atoms/workspace.ts`:
- `allFilesWithContentPendingAtom` (line 117)
- `chartsBeforeApplyingContentPendingAtom` (line 107)

But they are **not used** in the test-ai-chat client component. No commit/discard buttons exist.

---

### 2. Revision Tracking - Critical Gap

#### PR1.7 Plan Assumption
The plan assumes AI changes go to `content_pending`, then user clicks "Commit Changes" to create revision.

#### Actual Behavior - Inconsistency Found

**`create` command** (`pkg/api/handlers/editor.go:156`):
- Writes directly to `content` column
- Does NOT use `content_pending`

```go
// editor.go:156
_, err = workspace.AddFileToChart(ctx, chartID, req.WorkspaceID, req.RevisionNumber, req.Path, req.Content)
```

**`str_replace` command** (`pkg/api/handlers/editor.go:245`):
- Writes to `content_pending` column
- Uses `SetFileContentPending()`

```go
// editor.go:245
err = workspace.SetFileContentPending(ctx, req.Path, req.RevisionNumber, foundFile.chartID, req.WorkspaceID, newContent)
```

#### Impact on PR1.7

The `createRevisionFromPendingAction()` sketch in PR1.7 uses:
```sql
COALESCE(content_pending, content)  -- Use pending if exists
```

This works for `str_replace` but newly created files via `create` command have `content` populated directly - they wouldn't show as "pending changes".

#### Required Change to PR1.7

**Option A**: Modify `AddFileToChart()` to write to `content_pending` instead of `content`

**Option B**: Modify the revision creation SQL to handle both cases:
```sql
-- Files with content_pending or newly created files
WHERE content_pending IS NOT NULL OR (content IS NOT NULL AND file was created after revision started)
```

**Option C**: Accept that `create` is always committed immediately, only `str_replace` changes can be discarded

**Recommendation**: Option A is cleanest - all AI modifications should use `content_pending` for consistency.

---

### 3. Centrifugo Integration - Confirmed Plan is Correct

#### Current State

**Event Type Defined** (`pkg/realtime/types/artifact-updated.go:9-24`):
```go
type ArtifactUpdatedEvent struct {
    WorkspaceID   string               `json:"workspaceId"`
    WorkspaceFile *workspacetypes.File `json:"file"`
}
```

**Frontend Handler EXISTS and WORKS** (`hooks/useCentrifugo.ts:164-264`):
- Finds matching file in workspace by ID or path
- Updates file in appropriate chart or loose files
- Triggers file selection after update

**Publishing**: NEVER HAPPENS
- No code in `pkg/api/handlers/editor.go` publishes this event
- No code in `pkg/workspace/file.go` publishes this event

#### PR1.7 Plan Validation

The PR1.7 plan to add publishing from Go endpoint is **correct**. Implementation should:

1. Get user IDs for workspace: `workspace.ListUserIDsForWorkspace(ctx, workspaceId)`
2. Create recipient: `realtimetypes.Recipient{UserIDs: userIDs}`
3. Publish event: `realtime.SendEvent(ctx, recipient, &realtimetypes.ArtifactUpdatedEvent{...})`

#### Additional Consideration

**User ID Source**: The textEditor handler receives an `Authorization` header but doesn't extract user ID. The PR1.7 plan mentions:

> "Need to pass userID to Go endpoint (or extract from auth header)"

Looking at the auth flow:
- `pkg/api/handlers/editor.go` receives requests but doesn't parse Authorization header for user ID
- Other handlers that publish events get user IDs via `workspace.ListUserIDsForWorkspace()`

**Recommendation**: Use `ListUserIDsForWorkspace()` pattern - publish to all users with workspace access, not just the requesting user.

---

### 4. Test-AI-Chat Centrifugo Integration

#### Current State
**useCentrifugo is NOT imported or used** in test-ai-chat.

Comment at `client.tsx:154`:
> "This is a simple solution for PR1.6; PR1.7 will use Centrifugo for real-time"

#### Required Changes for PR1.7

1. Import and use `useCentrifugo` hook in `TestAIChatClient`
2. Remove or disable the refetch-after-tool-completion useEffect
3. Workspace updates will flow automatically via atom updates from Centrifugo events

#### Example Integration

```typescript
// In TestAIChatClient
import { useCentrifugo } from "@/hooks/useCentrifugo";

export function TestAIChatClient({ workspace, session }: TestAIChatClientProps) {
  // Add Centrifugo integration
  const { isReconnecting } = useCentrifugo({ session });

  // Remove the refetch useEffect (lines 153-169)
  // File explorer now updates automatically via workspaceAtom changes
}
```

---

### 5. Plan Workflow - Parallel System Concern

#### Existing Plan System

The main path uses a complex Go-worker-based Plan system:
1. Go worker receives `new_plan` job
2. LLM generates plan description
3. Status changes: `pending` → `planning` → `review`
4. User clicks "Proceed"
5. `createRevision()` creates new revision
6. Go worker executes `execute_plan` → `apply_plan`
7. Files modified via `SetFileContentPending()`
8. Status: `applying` → `applied`

**Files**:
- `pkg/listener/new-plan.go`
- `pkg/listener/execute-plan.go`
- `pkg/listener/apply-plan.go`
- `components/PlanChatMessage.tsx`

#### PR1.7 Proposed System

PR1.7 proposes a **separate mechanism** for AI SDK path:
- New `planProposal` tool defined in TypeScript
- Client-side plan rendering via `PlanProposalCard`
- Apply executes changes via textEditor tool calls
- No Go worker involvement

#### Concerns

1. **Two parallel Plan mechanisms** - confusing for users and developers
2. **No plan persistence** (Option B in PR1.7) means plans can't be reviewed later
3. **Different execution model** - direct tool calls vs worker queue

#### Questions for PR1.7

1. Should AI SDK plans use the same `workspace_plan` table for consistency?
2. If yes, how do we trigger Go worker execution from AI SDK path?
3. If no, are we okay with two different Plan experiences?

#### Recommendation

Consider **Option A from PR1.7 with persistence**:
1. Create `planProposal` tool that saves to `workspace_plan` table with status `review`
2. Reuse `PlanChatMessage.tsx` component for display
3. On "Apply", execute changes via textEditor tools (not Go worker)
4. Update plan status to `applied` after completion

This provides:
- Consistent UI experience
- Plan persistence and audit trail
- Simpler architecture (no Go worker for AI SDK path)

---

### 6. Accept/Reject Patch Functions - Already Exist

PR1.7 doesn't need to create commit/discard from scratch. The functions already exist:

**Accept (Commit)**:
- `lib/workspace/patch.ts:126-150` - `acceptPatch()`
- `lib/workspace/actions/accept-patch.ts:10-45` - `acceptPatchAction()`
- Sets `content = content_pending, content_pending = NULL`

**Reject (Discard)**:
- `lib/workspace/patch.ts:76-96` - `rejectPatch()`
- `lib/workspace/actions/reject-patch.ts:9-22` - `rejectPatchAction()`
- Sets `content_pending = NULL`

**Batch Operations**:
- `acceptAllPatches()` - Commits all pending changes
- `rejectAllPatches()` - Discards all pending changes

**Required for PR1.7**: Just add UI buttons that call these existing actions.

---

## Code References

### Test-AI-Chat Implementation
- `chartsmith/chartsmith-app/app/test-ai-chat/[workspaceId]/client.tsx` - Main client component
- `chartsmith/chartsmith-app/app/test-ai-chat/page.tsx` - Landing page
- `chartsmith/chartsmith-app/app/test-ai-chat/[workspaceId]/page.tsx` - Server component

### Revision System
- `chartsmith/chartsmith-app/lib/workspace/workspace.ts:946-1068` - `createRevision()`
- `chartsmith/pkg/workspace/revision.go:47-155` - Go `CreateRevision()`
- `chartsmith/chartsmith-app/lib/workspace/patch.ts:76-150` - Accept/reject functions

### Centrifugo
- `chartsmith/chartsmith-app/hooks/useCentrifugo.ts:164-264` - `handleArtifactUpdated()`
- `chartsmith/pkg/realtime/types/artifact-updated.go` - Event type definition
- `chartsmith/pkg/realtime/centrifugo.go:48-66` - `SendEvent()`

### TextEditor Tool
- `chartsmith/chartsmith-app/lib/ai/tools/textEditor.ts` - Tool definition
- `chartsmith/pkg/api/handlers/editor.go:37-257` - Go handler
- `chartsmith/pkg/workspace/file.go:107-165` - `SetFileContentPending()`
- `chartsmith/pkg/workspace/chart.go:38-54` - `AddFileToChart()`

### Plan System
- `chartsmith/pkg/listener/new-plan.go` - Plan creation worker
- `chartsmith/pkg/listener/apply-plan.go` - Plan execution worker
- `chartsmith/chartsmith-app/components/PlanChatMessage.tsx` - Plan UI component

---

## Questions for PR1.7 Implementation

### Critical Questions

1. **Inconsistent content handling**: Should `create` command write to `content_pending` instead of `content`? This affects the entire revision tracking model.

2. **Refetch vs Centrifugo**: Should we remove the refetch-after-tool-completion logic when adding Centrifugo, or keep it as fallback?

3. **Plan workflow approach**: Should AI SDK plans persist to `workspace_plan` table, or remain client-side only?

### Implementation Questions

4. **Pending changes scope**: Should "Commit Changes" create a revision for the entire workspace or just files with `content_pending`?

5. **User navigation warning**: What happens if user navigates away with uncommitted changes? Browser beforeunload warning?

6. **Centrifugo user targeting**: Should artifact-updated events go to all workspace users or just the user making changes?

### Nice-to-Have Questions

7. **Undo after commit**: Once changes are committed to a revision, can user rollback? (Existing rollback mechanism exists)

8. **Partial commit**: Should users be able to commit some files but not others? (Batch vs individual)

---

## Recommended Changes to PR1.7 PRDs

### Priority 1: Fix Content Handling Inconsistency

Update `AddFileToChart()` in `pkg/workspace/chart.go` to write to `content_pending`:
```go
// Instead of:
INSERT INTO workspace_file (..., content) VALUES (..., $content)

// Use:
INSERT INTO workspace_file (..., content, content_pending) VALUES (..., '', $content)
```

Or create new function `AddFileToChartPending()` for AI SDK path.

### Priority 2: Add Centrifugo Publishing Details

Expand the Go implementation sketch to show exact code:
```go
// pkg/api/handlers/editor.go - after successful str_replace
userIDs, err := workspace.ListUserIDsForWorkspace(ctx, req.WorkspaceID)
if err != nil {
    log.Error("Failed to get user IDs for realtime", "error", err)
    // Don't fail the request, just skip realtime
} else {
    recipient := realtimetypes.Recipient{UserIDs: userIDs}
    event := &realtimetypes.ArtifactUpdatedEvent{
        WorkspaceID:   req.WorkspaceID,
        WorkspaceFile: updatedFile,
    }
    if err := realtime.SendEvent(ctx, recipient, event); err != nil {
        log.Error("Failed to send artifact update", "error", err)
    }
}
```

### Priority 3: Clarify Plan Workflow Decision

Add explicit decision in PR1.7 about:
1. Whether AI SDK plans persist to database
2. Whether to reuse `PlanChatMessage.tsx` or create new component
3. Whether plans can be "Proceeded" via Go worker or just client-side execution

### Priority 4: Document Accept/Reject Reuse

Update PR1.7 to note that accept/reject functions already exist:
- No new server actions needed for commit/discard
- Just need UI buttons calling existing `acceptPatchAction()` and `rejectPatchAction()`

---

## Open Questions

1. **Multi-tab behavior**: If user has workspace open in multiple tabs, will Centrifugo events cause conflicts when both receive updates?

2. **Offline handling**: What happens if Centrifugo disconnects during AI tool execution? The refetch approach handles this, but pure Centrifugo wouldn't.

3. **Performance**: Creating a revision copies all files. For large workspaces, should we optimize to only copy changed files?

---

*Research complete. PR1.7 plan is fundamentally sound but needs the above refinements before implementation.*
