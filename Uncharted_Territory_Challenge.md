# **THE UNCHARTED TERRITORY CHALLENGE**

## **Overview**

Most of you have never built the software you’re about to create. Now, we’re raising the stakes: you’re not starting from scratch. You will **fork an existing open-source repository** in a **programming language and ecosystem you’ve never used**, understand it, extend it, and ship production-quality software.

In the real world, most engineering work is brownfield. You inherit legacy designs, unfamiliar architecture, and someone else’s technical decisions. This challenge simulates that reality and proves you can use AI to rapidly learn, adapt, and build in unfamiliar territory.

## **Core Objective**

You will:

1. **Fork a substantial open-source repository**

2. **Learn a new programming language \+ tech ecosystem**

3. **Understand the existing architecture**

4. **Design and build a non-trivial feature or transformation**

5. **Ship production-ready software, documented and demoed**

You cannot create a new repo from scratch. The starting point must be an existing project, just like Cursor forked VS Code to build their product.

# 

# **PROJECT REQUIREMENTS**

## **1\. New Territory**

* You must use a programming language and major framework you’ve never worked with before.

* The codebase you fork should be substantial enough to challenge you (recommended: 1,000+ stars).

## **2\. Brownfield Only**

Your project *must* start with:

* A fork of an existing open-source repository

* Real architecture someone else designed

* Existing modules, patterns, and constraints

No greenfield projects.

## **3\. Complexity**

Your contribution must be non-trivial—equivalent to what a team might build in 1–2 weeks:

* New real-time features

* Plugin/extension systems

* Cloud enablement

* Major UI expansions

* AI integrations

* New interfaces on top of an existing engine

## **4\. Quality & Deployment**

Your final deliverable must be:

* Fully functional

* Stable

* Deployed or trivially runnable

## **5\. Documentation**

Include:

* The repo you forked

* What you added

* Architecture overview

* Setup instructions

* Justification for your technical decisions

# 

# **DEVELOPMENT FRAMEWORK**

## **DAY 1–2: Research, Learning, and Codebase Onboarding**

### **1\. Repo & Tech Selection**

Use AI to:

* Compare open-source repos

* Review documentation quality

* Understand architecture at a high level

* Validate ecosystem maturity

### **2\. AI-Driven Codebase Onboarding**

Ask AI to help you:

* Summarize key directories

* Explain architectural concepts

* Identify extension points

* Map data flows

Produce:

* A codebase map

* A learning plan for the new language/framework

* Small POCs if needed

### **3\. Architecture Planning**

Define:

* The feature you are building

* Exactly where it integrates

* What modules you’ll need to modify

* Risks and unknowns

## **DAY 3–5: Core Development**

### **1\. Implement the Core Feature**

Your first milestone: get the feature working end-to-end.

Use AI to:

* Explain unfamiliar patterns

* Debug errors

* Suggest best practices

* Analyze performance

### **2\. Feature Expansion**

* Add secondary features

* Address edge cases

* Improve UI/UX

### **3\. Quality Improvements**

* Refactor for clarity

* Add tests where appropriate

* Optimize performance bottlenecks

## **DAY 6–7: Polish, Documentation, Deployment**

### **1\. Final UX & Polish**

* Improve clarity

* Enhance user flow

* Remove friction

### **2\. Test Thoroughly**

* Validate user flows

* Test edge cases

* Fix bugs

### **3\. Documentation**

Produce:

* README (clear, complete)

* Architecture explanation

* Setup steps

* What you changed in the original repo

### **4\. Deploy**

Deploy your project or create an extremely simple local run path.

# 

# **EVALUATION CRITERIA**

## **1\. Brownfield Mastery**

* Did you successfully extend a real-world codebase?

* Did you demonstrate understanding of how the system works?

* Is your integration clean, consistent, and intentional?

## **2\. Technical Achievement**

* Stability and functionality

* Code quality despite new territory

* Real performance, not just “it runs”

## **3\. Learning Velocity**

* How quickly you became productive in a new ecosystem

* How well you leveraged AI

* Quality of your documented methodology

## **4\. Software Quality**

* Reliability

* UX & polish

* Error handling

## **5\. Ambition & Scope**

* Was this genuinely challenging?

* Did you push into unfamiliar areas?

* Did you build something meaningful?

# **DELIVERABLES**

## **1\. Forked GitHub Repository**

* Clear commit history

* Marked changes/additions

* Clean project structure

## **2\. Working Software**

* Deployed or easily runnable

* Demonstrates core feature(s) end-to-end

## **3\. README Documentation**

Must include:

* Original repo

* What you built

* Architecture overview

* Setup \+ run steps

* Technical decisions

## **4\. Brainlift Documentation**

Daily logs including:

* AI prompts

* Learning breakthroughs

* Technical decisions

* What changed \+ why

* Challenges & solutions

## **5\. Demo Video (5 minutes)**

Include:

* Project introduction

* What repo you forked & why

* Feature walkthrough

* Technical architecture

* How AI accelerated your development

* Reflection on learning

# 

# **EXAMPLE OPEN-SOURCE REPOS TO FORK**

Below are repos that are substantial, well-documented, and excellent for brownfield modification in unfamiliar languages.

## **1\. Desktop Apps (Good for UI-heavy or Editor-like projects)**

**VS Code (TypeScript)**

https://github.com/microsoft/vscode

*What you could build:*

* AI agent integration

* New debugging tools

* Real-time collaboration

**Zed Editor (Rust)**

https://github.com/zed-industries/zed

*What you could build:*

* New language support

* Plugin system

* Cloud sync

## **2\. Web Applications & Frameworks**

**Mattermost (Go \+ React)**

https://github.com/mattermost/mattermost

*Possible projects:*

* AI summarization

* Custom integrations

* Notification system upgrades

**Gitea (Go)**

https://github.com/go-gitea/gitea

*Possible projects:*

* AI-powered code review

* Repo insights

* Issue triaging

## **3\. CLIs & Dev Tools**

**Helm (Go)**

https://github.com/helm/helm

*Possible projects:*

* Template validation tools

* Environment debugging features

**Ripgrep (Rust)**

https://github.com/BurntSushi/ripgrep

*Possible projects:*

* AI-based search layers

* Custom filtering pipelines

## **4\. Backends, Servers, Engines**

**PocketBase (Go)**

https://github.com/pocketbase/pocketbase

*Possible projects:*

* Admin UI improvements

* Rules engine

* AI-powered query assistant

**MinIO (Go)**

https://github.com/minio/minio

*Possible projects:*

* Observability enhancements

* Storage analytics dashboard

## **5\. Misc \+ Fun**

**Godot Engine (C++)**

https://github.com/godotengine/godot

*Possible projects:*

* AI NPC behavior engine

* Visual debugging tools

**Home Assistant (Python)**

https://github.com/home-assistant/core

*Possible projects:*

* New device integrations

* Automation templates