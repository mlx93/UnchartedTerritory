---
date: 2025-12-02T22:45:00Z
researcher: Claude Code + mlx93
git_commit: e615830f7b0b60ecb817d762b9b4e4186f855d85
branch: main
repository: UnchartedTerritory (Chartsmith codebase)
topic: "PR1.5 Implementation Guide - Combined Research & Decisions"
tags: [research, implementation, pr1.5, go-http-server, tools, decisions]
status: complete
last_updated: 2025-12-02
last_updated_by: Claude Code
---

# PR1.5 Implementation Guide

**Purpose**: This document combines all codebase research with architectural decisions to provide clear instructions for building the PR1.5 detailed PRD.

**Supersedes**: 
- `2025-12-02-pr1.5-codebase-verification.md` (research findings)
- `2025-12-02-pr1.5-codebase-verification_revised.md` (additional research)

**Source Documents**:
- `PRDs/PR1.5_PLAN.md` - Current task list
- `PRDs/PR1.5_HIGH_LEVEL_SUMMARY_REVISED.md` - Current specs
- `PRDs/PR1.5 Go Handlers Imp Notes.md` - Handler guidance
- `PRDs/PR1_Tech_PRD.md` - PR1 context (what exists before PR1.5)

---

## Executive Summary

PR1.5 adds **tools to the AI SDK chat system** created by PR1. This requires:

1. **New Go HTTP Server** (port 8080) - doesn't exist today
2. **6 AI SDK Tool Definitions** in TypeScript - call Go endpoints
3. **Go HTTP Handlers** - execute tool logic using existing functions

### Key Decisions Made

| Question | Decision | Rationale |
|----------|----------|-----------|
| Workspace creation | Go implements own SQL | Simplicity principle, no network hop |
| K8s versions | Keep hardcoded | Feature parity, simplicity |
| text_editor `insert` | Remove from PRD | Doesn't exist in codebase |
| Auth pattern | Go validates extension tokens | Match existing Next.js pattern |
| HTTP router | `net/http.ServeMux` | No external dependencies needed |

---

## Part 1: What PR1 Creates (Context)

Before PR1.5 begins, PR1 will have created:

```
chartsmith-app/
├── app/api/chat/route.ts      # NEW - AI SDK streaming (NO TOOLS)
├── lib/ai/
│   ├── provider.ts            # NEW - OpenRouter factory
│   ├── models.ts              # NEW - Model definitions
│   └── config.ts              # NEW - AI configuration
└── components/chat/
    └── ProviderSelector.tsx   # NEW - Model selection UI
```

**Critical**: PR1's `/api/chat/route.ts` has **NO tools**. PR1.5 adds them.

---

## Part 2: Corrected Function Reference

### Functions That EXIST (Use These)

| Purpose | Function | Location | Signature |
|---------|----------|----------|-----------|
| Load workspace | `GetWorkspace` | `pkg/workspace/workspace.go:63` | `func GetWorkspace(ctx, id string) (*types.Workspace, error)` |
| Create revision | `CreateRevision` | `pkg/workspace/revision.go:47` | `func CreateRevision(ctx, workspaceID, planID *string, userID string) (types.Revision, error)` |
| List files | `ListFiles` | `pkg/workspace/file.go:65` | `func ListFiles(ctx, workspaceID string, revisionNumber int, chartID string) ([]types.File, error)` |
| Get file | `GetFile` | `pkg/workspace/file.go:15` | `func GetFile(ctx, fileID string, revisionNumber int) (*types.File, error)` |
| Update file | `SetFileContentPending` | `pkg/workspace/file.go:107` | `func SetFileContentPending(ctx, path string, revisionNumber int, chartID, workspaceID, contentPending string) error` |
| Create chart | `CreateChart` | `pkg/workspace/chart.go:15` | `func CreateChart(ctx, workspaceID string, revisionNumber int) (*types.Chart, error)` |
| Add file | `AddFileToChart` | `pkg/workspace/chart.go:38` | `func AddFileToChart(ctx, chartID, workspaceID string, revisionNumber int, path, content string) error` |
| Apply patch | `ApplyPatch` | `pkg/diff/apply.go:29` | `func ApplyPatch(content, patchText string) (string, error)` |
| String replace | `PerformStringReplacement` | `pkg/llm/execute-action.go:238` | `func PerformStringReplacement(content, oldStr, newStr string) (string, bool, error)` |
| Subchart version | `GetLatestSubchartVersion` | `pkg/recommendations/subchart.go:21` | `func GetLatestSubchartVersion(chartName string) (string, error)` |
| Queue work | `EnqueueWork` | `pkg/persistence/queue.go:10` | `func EnqueueWork(ctx, channel string, payload interface{}) error` |
| Check ownership | `ListUserIDsForWorkspace` | `pkg/workspace/workspace.go:14` | `func ListUserIDsForWorkspace(ctx, workspaceID string) ([]string, error)` |

### Functions That DO NOT EXIST (Must Create)

| Purpose | What to Create | Pattern to Follow |
|---------|----------------|-------------------|
| Create workspace | `CreateWorkspaceForChart()` in `pkg/api/handlers/charts.go` | Copy SQL from `chartsmith-app/lib/workspace/workspace.ts:30-99` |
| Validate token | `ValidateExtensionToken()` in `pkg/api/auth.go` | Query `extension_token` table like `lib/auth/extension-token.ts:23` |
| HTTP server | `StartHTTPServer()` in `pkg/api/server.go` | Standard `http.ListenAndServe` |

---

## Part 3: PRD Corrections Required

### Update PR1.5_PLAN.md

#### Section: "Go Handler Implementation Guidance" (lines 326-338)

**REMOVE these incorrect references:**
```markdown
- CreateWorkspace(ctx, userID, name)
- InitializeWorkspaceFiles(workspaceID, type, opts)
- CreateInitialRevision(workspaceID, files)
- workspace.Notify(ctx, workspaceID, "chart_created")
- workspace.LoadByID(workspaceID)
- revisions.GetLatest(workspaceID)
- workspaceFiles.List(revision.ID)
```

**REPLACE WITH:**
```markdown
## Go Handler Implementation Guidance

### Existing Functions to Reuse

**Workspace/Revision Operations:**
- `workspace.GetWorkspace(ctx, id)` - Load workspace with files, charts, plans
- `workspace.CreateRevision(ctx, workspaceID, planID, userID)` - Create new revision
- `workspace.ListFiles(ctx, workspaceID, revisionNumber, chartID)` - Get file list
- `workspace.SetFileContentPending(ctx, path, revisionNumber, chartID, workspaceID, content)` - Update file

**Chart Operations:**
- `workspace.CreateChart(ctx, workspaceID, revisionNumber)` - Create empty chart
- `workspace.AddFileToChart(ctx, chartID, workspaceID, revisionNumber, path, content)` - Add file to chart

**Patch/Edit Operations:**
- `diff.ApplyPatch(content, patchText)` - Apply unified diff
- `llm.PerformStringReplacement(content, oldStr, newStr)` - String replacement with fuzzy matching

**Notifications:**
- `persistence.EnqueueWork(ctx, "render_workspace", payload)` - Trigger render
- `persistence.EnqueueWork(ctx, "new_summarize", payload)` - Generate embeddings

**Tool Logic (Reuse Directly):**
- `recommendations.GetLatestSubchartVersion(chartName)` - ArtifactHub lookup

### New Functions to Create

**Authentication (pkg/api/auth.go):**
```go
func ValidateExtensionToken(ctx context.Context, token string) (userID string, err error)
func ValidateWorkspaceAccess(ctx context.Context, workspaceID, userID string) error
```

**Workspace Creation (pkg/api/handlers/charts.go):**
```go
func CreateWorkspaceForChart(ctx context.Context, userID, name, chartType string) (*types.Workspace, error)
```
- Pattern: Copy SQL from `chartsmith-app/lib/workspace/workspace.ts:30-99`
- Must: Copy from bootstrap tables, create revision 0, enqueue render
```

#### Section: Task 11 textEditor Tool (lines 167-194)

**REMOVE `insert` command:**
```markdown
parameters: z.object({
    command: z.enum(['view', 'create', 'str_replace', 'insert']),  // WRONG
```

**REPLACE WITH:**
```markdown
parameters: z.object({
    command: z.enum(['view', 'create', 'str_replace']),  // CORRECT - matches codebase
```

**REMOVE `insertLine` and `insertText` parameters** - these don't exist in the implementation.

#### Section: Task 9 latestKubernetesVersion (lines 113-131)

**REMOVE channel parameter:**
```markdown
parameters: z.object({
    channel: z.enum(['stable', 'latest', 'all']).optional()  // WRONG
```

**REPLACE WITH:**
```markdown
parameters: z.object({
    semverField: z.enum(['major', 'minor', 'patch']).optional()
      .describe('Which part of version to return (defaults to patch for full version)'),
}),
```

**ADD implementation note:**
```markdown
**Implementation Note**: Returns hardcoded values matching current behavior:
- "major" → "1"
- "minor" → "1.32"  
- "patch" → "1.32.1"

This is intentional for stability. Live API lookup is a future enhancement.
```

---

## Part 4: File-by-File Implementation Spec

### New Go Files

#### 1. `pkg/api/server.go`

```go
package api

import (
    "context"
    "net/http"
    "github.com/replicatedhq/chartsmith/pkg/api/handlers"
)

func StartHTTPServer(ctx context.Context, port string) error {
    mux := http.NewServeMux()
    
    // Chart endpoints
    mux.HandleFunc("POST /api/tools/charts/create", handlers.CreateChart)
    mux.HandleFunc("GET /api/tools/charts/{id}", handlers.GetChartContext)
    mux.HandleFunc("PATCH /api/tools/charts/{id}", handlers.UpdateChart)
    
    // Editor endpoint
    mux.HandleFunc("POST /api/tools/editor", handlers.TextEditor)
    
    // Version endpoints
    mux.HandleFunc("POST /api/tools/versions/subchart", handlers.GetSubchartVersion)
    mux.HandleFunc("POST /api/tools/versions/kubernetes", handlers.GetKubernetesVersion)
    
    server := &http.Server{
        Addr:    ":" + port,
        Handler: mux,
    }
    
    go func() {
        <-ctx.Done()
        server.Shutdown(context.Background())
    }()
    
    return server.ListenAndServe()
}
```

#### 2. `pkg/api/auth.go`

```go
package api

import (
    "context"
    "errors"
    "net/http"
    "strings"
    
    "github.com/replicatedhq/chartsmith/pkg/persistence"
    "github.com/replicatedhq/chartsmith/pkg/workspace"
)

var (
    ErrUnauthorized = errors.New("unauthorized")
    ErrForbidden    = errors.New("forbidden")
)

// ValidateExtensionToken checks the extension_token table
func ValidateExtensionToken(ctx context.Context, token string) (string, error) {
    conn := persistence.MustGetPooledPostgresSession()
    defer conn.Release()
    
    var userID string
    err := conn.QueryRow(ctx, 
        `SELECT user_id FROM extension_token WHERE token = $1`, 
        token,
    ).Scan(&userID)
    
    if err != nil {
        return "", ErrUnauthorized
    }
    return userID, nil
}

// ValidateWorkspaceAccess checks if user owns the workspace
func ValidateWorkspaceAccess(ctx context.Context, workspaceID, userID string) error {
    ownerIDs, err := workspace.ListUserIDsForWorkspace(ctx, workspaceID)
    if err != nil || len(ownerIDs) == 0 {
        return ErrForbidden
    }
    if ownerIDs[0] != userID {
        return ErrForbidden
    }
    return nil
}

// ExtractUserID is middleware helper
func ExtractUserID(r *http.Request) (string, error) {
    auth := r.Header.Get("Authorization")
    if auth == "" {
        return "", ErrUnauthorized
    }
    token := strings.TrimPrefix(auth, "Bearer ")
    return ValidateExtensionToken(r.Context(), token)
}
```

#### 3. `pkg/api/errors.go`

```go
package api

import (
    "encoding/json"
    "net/http"
)

type ErrorResponse struct {
    Success bool   `json:"success"`
    Message string `json:"message"`
    Code    string `json:"code,omitempty"`
}

func WriteError(w http.ResponseWriter, status int, message string) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    json.NewEncoder(w).Encode(ErrorResponse{
        Success: false,
        Message: message,
    })
}

func WriteJSON(w http.ResponseWriter, status int, data interface{}) {
    w.Header().Set("Content-Type", "application/json")
    w.WriteHeader(status)
    json.NewEncoder(w).Encode(data)
}
```

#### 4. `pkg/api/handlers/charts.go`

```go
package handlers

import (
    "encoding/json"
    "net/http"
    
    "github.com/replicatedhq/chartsmith/pkg/api"
    "github.com/replicatedhq/chartsmith/pkg/persistence"
    "github.com/replicatedhq/chartsmith/pkg/workspace"
    srs "github.com/thanhpk/randstr"
)

type CreateChartRequest struct {
    Name        string `json:"name"`
    Description string `json:"description"`
    Type        string `json:"type,omitempty"`
}

type CreateChartResponse struct {
    Success     bool   `json:"success"`
    WorkspaceID string `json:"workspaceId"`
    RevisionID  int    `json:"revisionNumber"`
    Message     string `json:"message"`
}

func CreateChart(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    // Auth
    userID, err := api.ExtractUserID(r)
    if err != nil {
        api.WriteError(w, http.StatusUnauthorized, "Unauthorized")
        return
    }
    
    // Parse request
    var req CreateChartRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        api.WriteError(w, http.StatusBadRequest, "Invalid request body")
        return
    }
    
    // Create workspace (following TypeScript pattern from workspace.ts:30-99)
    workspaceID := srs.String(12)
    conn := persistence.MustGetPooledPostgresSession()
    defer conn.Release()
    
    tx, err := conn.Begin(ctx)
    if err != nil {
        api.WriteError(w, http.StatusInternalServerError, "Database error")
        return
    }
    defer tx.Rollback(ctx)
    
    // Get bootstrap workspace
    var bootstrapName string
    err = tx.QueryRow(ctx, 
        `SELECT name FROM bootstrap_workspace WHERE name = 'default-workspace'`,
    ).Scan(&bootstrapName)
    if err != nil {
        api.WriteError(w, http.StatusInternalServerError, "Bootstrap not found")
        return
    }
    
    // Insert workspace
    _, err = tx.Exec(ctx, `
        INSERT INTO workspace (id, created_at, last_updated_at, name, created_by_user_id, created_type, current_revision_number)
        VALUES ($1, now(), now(), $2, $3, 'chat', 0)
    `, workspaceID, req.Name, userID)
    if err != nil {
        api.WriteError(w, http.StatusInternalServerError, "Failed to create workspace")
        return
    }
    
    // Insert initial revision
    _, err = tx.Exec(ctx, `
        INSERT INTO workspace_revision (workspace_id, revision_number, created_at, created_by_user_id, created_type, is_complete, is_rendered)
        VALUES ($1, 0, now(), $2, 'chat', true, false)
    `, workspaceID, userID)
    if err != nil {
        api.WriteError(w, http.StatusInternalServerError, "Failed to create revision")
        return
    }
    
    // Copy bootstrap charts and files (similar to workspace.ts:68-98)
    _, err = tx.Exec(ctx, `
        INSERT INTO workspace_chart (id, workspace_id, name, revision_number)
        SELECT $1 || '_' || id, $2, name, 0
        FROM bootstrap_chart
    `, srs.String(8), workspaceID)
    if err != nil {
        api.WriteError(w, http.StatusInternalServerError, "Failed to copy charts")
        return
    }
    
    // ... (copy files from bootstrap_file - similar pattern)
    
    if err := tx.Commit(ctx); err != nil {
        api.WriteError(w, http.StatusInternalServerError, "Failed to commit")
        return
    }
    
    // Enqueue render
    persistence.EnqueueWork(ctx, "render_workspace", map[string]interface{}{
        "workspaceId":    workspaceID,
        "revisionNumber": 0,
    })
    
    api.WriteJSON(w, http.StatusCreated, CreateChartResponse{
        Success:     true,
        WorkspaceID: workspaceID,
        RevisionID:  0,
        Message:     "Chart created successfully",
    })
}

func GetChartContext(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    userID, err := api.ExtractUserID(r)
    if err != nil {
        api.WriteError(w, http.StatusUnauthorized, "Unauthorized")
        return
    }
    
    workspaceID := r.PathValue("id")
    if err := api.ValidateWorkspaceAccess(ctx, workspaceID, userID); err != nil {
        api.WriteError(w, http.StatusNotFound, "Workspace not found")
        return
    }
    
    ws, err := workspace.GetWorkspace(ctx, workspaceID)
    if err != nil {
        api.WriteError(w, http.StatusNotFound, "Workspace not found")
        return
    }
    
    api.WriteJSON(w, http.StatusOK, ws)
}

func UpdateChart(w http.ResponseWriter, r *http.Request) {
    // Similar pattern: auth, validate access, apply changes, return result
    // Use workspace.CreateRevision() for versioning
}
```

#### 5. `pkg/api/handlers/versions.go`

```go
package handlers

import (
    "encoding/json"
    "net/http"
    
    "github.com/replicatedhq/chartsmith/pkg/api"
    "github.com/replicatedhq/chartsmith/pkg/recommendations"
)

type SubchartVersionRequest struct {
    ChartName  string `json:"chartName"`
    Repository string `json:"repository,omitempty"`
}

type SubchartVersionResponse struct {
    Success bool   `json:"success"`
    Version string `json:"version"`
    Name    string `json:"name"`
}

func GetSubchartVersion(w http.ResponseWriter, r *http.Request) {
    // Auth (optional for this endpoint, but consistent)
    _, err := api.ExtractUserID(r)
    if err != nil {
        api.WriteError(w, http.StatusUnauthorized, "Unauthorized")
        return
    }
    
    var req SubchartVersionRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        api.WriteError(w, http.StatusBadRequest, "Invalid request")
        return
    }
    
    // Reuse existing function
    version, err := recommendations.GetLatestSubchartVersion(req.ChartName)
    if err != nil {
        // Match existing behavior: return "?" for not found
        api.WriteJSON(w, http.StatusOK, SubchartVersionResponse{
            Success: true,
            Version: "?",
            Name:    req.ChartName,
        })
        return
    }
    
    api.WriteJSON(w, http.StatusOK, SubchartVersionResponse{
        Success: true,
        Version: version,
        Name:    req.ChartName,
    })
}

type KubernetesVersionRequest struct {
    SemverField string `json:"semverField,omitempty"` // major, minor, patch
}

type KubernetesVersionResponse struct {
    Success bool   `json:"success"`
    Version string `json:"version"`
    Field   string `json:"field"`
}

func GetKubernetesVersion(w http.ResponseWriter, r *http.Request) {
    _, err := api.ExtractUserID(r)
    if err != nil {
        api.WriteError(w, http.StatusUnauthorized, "Unauthorized")
        return
    }
    
    var req KubernetesVersionRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        req.SemverField = "patch" // default
    }
    
    // Hardcoded values matching existing behavior (conversational.go:175-191)
    var version string
    switch req.SemverField {
    case "major":
        version = "1"
    case "minor":
        version = "1.32"
    case "patch", "":
        version = "1.32.1"
    default:
        version = "1.32.1"
    }
    
    api.WriteJSON(w, http.StatusOK, KubernetesVersionResponse{
        Success: true,
        Version: version,
        Field:   req.SemverField,
    })
}
```

#### 6. `pkg/api/handlers/editor.go`

```go
package handlers

import (
    "encoding/json"
    "net/http"
    
    "github.com/replicatedhq/chartsmith/pkg/api"
    "github.com/replicatedhq/chartsmith/pkg/llm"
    "github.com/replicatedhq/chartsmith/pkg/workspace"
)

type TextEditorRequest struct {
    Command     string `json:"command"`     // view, create, str_replace
    WorkspaceID string `json:"workspaceId"`
    Path        string `json:"path"`
    Content     string `json:"content,omitempty"`   // for create
    OldStr      string `json:"oldStr,omitempty"`    // for str_replace
    NewStr      string `json:"newStr,omitempty"`    // for str_replace
}

type TextEditorResponse struct {
    Success bool   `json:"success"`
    Content string `json:"content,omitempty"`
    Message string `json:"message,omitempty"`
}

func TextEditor(w http.ResponseWriter, r *http.Request) {
    ctx := r.Context()
    
    userID, err := api.ExtractUserID(r)
    if err != nil {
        api.WriteError(w, http.StatusUnauthorized, "Unauthorized")
        return
    }
    
    var req TextEditorRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        api.WriteError(w, http.StatusBadRequest, "Invalid request")
        return
    }
    
    // Validate workspace access
    if err := api.ValidateWorkspaceAccess(ctx, req.WorkspaceID, userID); err != nil {
        api.WriteError(w, http.StatusNotFound, "Workspace not found")
        return
    }
    
    // Get workspace to find current revision and file
    ws, err := workspace.GetWorkspace(ctx, req.WorkspaceID)
    if err != nil {
        api.WriteError(w, http.StatusNotFound, "Workspace not found")
        return
    }
    
    // Find file in workspace
    var currentContent string
    var chartID string
    for _, chart := range ws.Charts {
        for _, file := range chart.Files {
            if file.FilePath == req.Path {
                currentContent = file.Content
                chartID = chart.ID
                break
            }
        }
    }
    
    switch req.Command {
    case "view":
        if currentContent == "" {
            api.WriteJSON(w, http.StatusOK, TextEditorResponse{
                Success: false,
                Message: "Error: File does not exist. Use create instead.",
            })
            return
        }
        api.WriteJSON(w, http.StatusOK, TextEditorResponse{
            Success: true,
            Content: currentContent,
        })
        
    case "create":
        if currentContent != "" {
            api.WriteJSON(w, http.StatusOK, TextEditorResponse{
                Success: false,
                Message: "Error: File already exists. Use view and str_replace instead.",
            })
            return
        }
        // Create file using existing function
        err := workspace.AddFileToChart(ctx, chartID, req.WorkspaceID, ws.CurrentRevision, req.Path, req.Content)
        if err != nil {
            api.WriteError(w, http.StatusInternalServerError, "Failed to create file")
            return
        }
        api.WriteJSON(w, http.StatusOK, TextEditorResponse{
            Success: true,
            Message: "Created",
        })
        
    case "str_replace":
        // Use existing fuzzy replacement function
        newContent, success, err := llm.PerformStringReplacement(currentContent, req.OldStr, req.NewStr)
        if err != nil || !success {
            api.WriteJSON(w, http.StatusOK, TextEditorResponse{
                Success: false,
                Message: "Error: String to replace not found in file.",
            })
            return
        }
        // Update file
        err = workspace.SetFileContentPending(ctx, req.Path, ws.CurrentRevision, chartID, req.WorkspaceID, newContent)
        if err != nil {
            api.WriteError(w, http.StatusInternalServerError, "Failed to update file")
            return
        }
        api.WriteJSON(w, http.StatusOK, TextEditorResponse{
            Success: true,
            Content: newContent,
            Message: "Content replaced successfully",
        })
        
    default:
        api.WriteError(w, http.StatusBadRequest, "Invalid command. Use: view, create, str_replace")
    }
}
```

### Modify Existing Go File

#### `cmd/run.go` - Add HTTP Server Startup

```go
// In runWorker function, after StartHeartbeat:

listener.StartHeartbeat(ctx)

// NEW: Start HTTP server for AI SDK tools
go func() {
    logger.Info("Starting HTTP server on port 8080")
    if err := api.StartHTTPServer(ctx, "8080"); err != nil && err != http.ErrServerClosed {
        logger.Error("HTTP server error", zap.Error(err))
    }
}()

if err := listener.StartListeners(ctx); err != nil {
    return fmt.Errorf("failed to start listeners: %w", err)
}
```

### New TypeScript Files

#### `lib/ai/tools/createChart.ts`

```typescript
import { tool } from 'ai';
import { z } from 'zod';
import { callGoEndpoint } from './utils';

export const createChart = tool({
  description: `Create a new Helm chart. Use when:
    - User wants to create a new chart
    - currentRevisionNumber is 0 and user expresses creation intent
    - User says "create", "new chart", "build a chart", etc.`,
  
  parameters: z.object({
    name: z.string().describe('Chart name (e.g., "nginx", "my-app")'),
    description: z.string().describe('What the chart should do'),
    type: z.enum(['deployment', 'statefulset', 'cronjob', 'custom'])
      .optional()
      .describe('Primary workload type'),
  }),

  execute: async (params) => {
    return callGoEndpoint('/api/tools/charts/create', params);
  },
});
```

#### `lib/ai/tools/utils.ts`

```typescript
const GO_BACKEND_URL = process.env.GO_BACKEND_URL || 'http://localhost:8080';

export async function callGoEndpoint<T>(
  endpoint: string, 
  body: Record<string, unknown>
): Promise<T> {
  const response = await fetch(`${GO_BACKEND_URL}${endpoint}`, {
    method: 'POST',
    headers: { 
      'Content-Type': 'application/json',
      // Forward auth header from original request (handled by route.ts)
    },
    body: JSON.stringify(body),
  });
  
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.message || `Go endpoint failed: ${response.status}`);
  }
  
  return response.json();
}
```

---

## Part 5: Validation Checklist for Detailed PRD

When writing the detailed PR1.5 PRD, ensure:

### Function References
- [ ] All Go function references match actual codebase signatures
- [ ] No references to non-existent functions (CreateWorkspace, etc.)
- [ ] Correct package names (workspace, persistence, diff, recommendations)

### Tool Definitions
- [ ] textEditor has only: view, create, str_replace (NO insert)
- [ ] latestKubernetesVersion uses semverField (NOT channel)
- [ ] latestSubchartVersion matches existing ArtifactHub integration

### Architecture
- [ ] HTTP server added to cmd/run.go, runs in goroutine
- [ ] Auth pattern matches existing extension token validation
- [ ] All handlers use persistence.MustGetPooledPostgresSession()

### Testing
- [ ] Integration tests for each HTTP endpoint
- [ ] Auth failure returns 401/404 (not 403 for security)
- [ ] Tool → Go HTTP → Response pattern verified

---

## Part 6: Open Items (Not Blockers)

These can be decided during implementation:

1. **Error logging**: Should handlers log to `str_replace_log` table like existing tool?
2. **Render trigger**: Should createChart auto-trigger render or let caller decide?
3. **File validation**: Should textEditor validate YAML syntax before saving?

---

*End of Implementation Guide*
